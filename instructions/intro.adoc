# TEB93D - Red Hat OpenShift Service Mesh in Action

## Purpose

As microservices-based applications become more prevalent, both the number of
and complexity of their interactions increases. Up until now much of the burden
of managing these complex microservices interactions has been placed on the
application developer, with different or non-existent support for microservice
concepts depending on language and framework.

The service mesh concept pushes this responsibility to the infrastructure, with
features for traffic management, distributed tracing and observability, policy
enforcement, and service/identity security, freeing the developer to focus on
business value. In this hands-on session you will learn how to apply some of
these features to a simple polyglot microservices application running on top of
OpenShift using Istio, an open platform to connect, manage, and secure
microservices.

## Background

Istio is an open platform to connect, manage, and secure microservices. Istio
provides an easy way to create a network of deployed services with load
balancing, service-to-service authentication, monitoring, and more, without
requiring any changes in application code. OpenShift can automatically inject a
special sidecar proxy throughout your environment to enable Istio management for
your application. This proxy intercepts all network communication between your
microservices microservices, and is configured and managed using Istioâ€™s control
plane functionality -- not your application code!

Kiali is an observability console designed to provide operational insight
into the behavior and performance of the service mesh as a whole.

Jaeger is a utility for capturing distributed tracing information of requests
as they travel throughout the mesh.

Prometheus and Grafana are used to capture metrics about the performance and
behavior of the mesh.

These components combined together are the Red Hat OpenShift Service Mesh.

## Conventions
You will see various code and command blocks throughout these exercises. Some of
the command blocks can be executed directly while others will require modification,
of the command before execution. If you see a command block with a red border
(see below), the command will require slight modification.

[source,none,role="copypaste copypaste-warning"]
----
some command to modify
----

If you hover over the command block above and left-click, it should automatically highlight all the text to make for easier copying.

Most command blocks support executing with a click.

Command blocks with looping scripts should be executed in the lower terminal like below

[source,bash,role="execute-2"]
----
for i in 1 2 3; do echo "hello $i"; done
----

If the loop continues for ever, you will have to click the lower terminal and press Ctrl+C to terminate the program.

[source,bash,role="execute-2"]
----
echo "A load generating script is running in the next step. Ctrl+C to stop"
while :;do echo "this won't print" &> /dev/null ; done
----

For ordinary commands, we will be using the upper terminal

[source,bash,role="execute-1"]
----
echo "Hello World"
----



## Getting Started
The machine you are sitting at has the OpenShift CLI installed. OpenShift 4 client is installed as `oc`.

You can verify it is working by simply typing:

[source,bash,role="execute-1"]
----
oc version
----

The Service Mesh control plane is already deployed with several application
components in an OpenShift Container Platform 4 environment. You will need to
use `oc` to interact with the API server.

The account you will be interacting with throughout the following exercises is a `ServiceAccount` with _cluster-admin_ `ClusterRole` binded to it to gives you privileges to access the resources on the cluster for this lab.

Have a look at your user account name

[source,bash,role="execute-1"]
----
oc whoami
----

Verify that you can create projects

[source,bash,role="execute-1"]
----
oc auth can-i create project
----

You can access the console by clicking on word *Console* on the toolbar above your terminal.